<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>linuxcram.github.io - 11_commands</title>
<style type="text/css">
header {
    width: 100%;
}
body {
  background: #333333;
  color: #f2f2f2;
  font-size: 14px;
  font-family: monospace;
  text-align: left;
  line-height: 1.3;
  margin: 0;
  border: 20px solid transparent;
}
a:link {
  color: #ff6000;
  background-color: transparent;
  text-decoration: none;
}
a:visited {
  color: #00bbbb;
  background-color: transparent;
  text-decoration: none;
}
a:active {
  color: #00bb00;
  background-color: transparent;
}
hr {
  height: 3px;
  background-color: #00ee00;
  border: none;
}
</style>
</head>
<body>
<center>
<img src="https://raw.githubusercontent.com/linuxcram/linuxcram.github.io/main/tux01.png" alt="Tux" width="33" height="33">
<h2>
linuxcram.github.io
<br>
[11_commands]
</h2>
</center>
<h3><a href="https://linuxcram.github.io/">HOME</a></h3>
<hr>
<h4>Common commands and best practice</h4>
<i>
Warning: ALWAYS use extra caution with potentially disruptive commands like rm, mv and with options that force (-f) or assumeyes (-y).
<br>
In Linux everything is a file, and once a file is gone, is gone. Forever. Without possibility of recover.
</i>
<br>
<br>
That's why good system administrators do double checks before applying changes, make backup copies, prefer absolute paths over relative.
<br>
<br>
Absolute paths begin with / and are referred to contents starting from the / root directory, they are precisely referred to a unique path.
<br>
<br>
When pointing to a directory, eg. with ls command, the last / can be omitted, only if there are no files in the specified path named exactly as the directory.
<br>
<br>
Absolute paths examples: /root /tmp/test /var /var/log/messages /home/user/Documents/file.txt
<br>
<br>
Relative paths with ./ prefix or no prefix point to contents in the current directory, with ../ prefix point to the parent directory. 
<br>
Relative paths examples: root ./Documents/ tmp/test var var/log/messages Documents/file.txt file.txt ../../../var/log ../home ../
<br>
<br>
<br>
<h4>Echo</h4>
The echo command works like a function that produces an output consisting of the arguments given, multiple arguments are accepted.
<br>
Echo provides options like -e (enable interpretation of backslash escapes) to let us write single lines.
<br>
The default input of echo is stdin (the arguments we type after the echo command).
<br>
The default output is stdout (the display if no redirection is set).
<br>
<br>
echo "hello" "all"
<br>
hello all
<br>
<br>
We can redirect the output of echo to a file, the output can be redirected to one single file only per command since the stdout can not be splitted.
<br>
<br>
echo -e "line1\nline2\nline3\nline4\nline5" > text.txt
<br>
echo -e "line6\nline7\nline8\nline9\nline10" > text2.txt
<br>
<br>
<b><i>Hints about "echo"</i></b>
<br>
The echo command is a Linux built-in command feature, that behave like a function which displays the arguments given as text, such as strings, variables values, output of commands.
<br>
Echo return status is always 0.
<br>
<br>
Common echo options are:
<pre>
-n    do not output the trailing newline
-e    enable interpretation of backslash escapes
-E    disable interpretation of backslash escapes (default)
</pre>
Echo escape sequences:
<pre>
\b    Backspace
\\    Backslash
\n    New Line
\r    Carriage Return
\t    Horizontal Tab
\v    Vertical Tab
</pre>
eg.
<br>
echo "Today is: $(date) - Logged as user: $(whoami) - Shell: $SHELL"; echo "Exit code: $?"
<br>
<br>
Today is: Mon Dec 12 11:22:29 AM CET 2022 - Logged as user: student - Shell: /bin/bash
<br>
Exit code: 0
<br>
<br>
<br>
<h4>Cat</h4>
The command cat executes concatenation of text, it's versatile and useful to merge contents together, this means that cat accepts multiple arguments.
<br>
Cat concatenates files and print on the standard output, wiithout arguments cat reads from standard input.
<br>
(try typing cat and enter, stdin is displayed on stdout, ctrl+c to exit).
<br>
<br>
cat text.txt text2.txt 
<br>
line1
<br>
line2
<br>
line3
<br>
line4
<br>
line5
<br>
line6
<br>
line7
<br>
line8
<br>
line9
<br>
line10
<br>
<br>
Other options are available for cat, like line numbers display.
<br>
<br>
cat -n text.txt text2.txt 
<br>
     1	line1
<br>
     2	line2
<br>
     3	line3
<br>
     4	line4
<br>
     5	line5
<br>
     6	line6
<br>
     7	line7
<br>
     8	line8
<br>
     9	line9
<br>
    10	line10
<br>
<br>
<br>
<h4>More</h4>
More is a command that displays the content of the files given as argument.
<br>
The contents of the files are shown one screen at a time for large files.
<br>
If the contents of the file fit a single screen, the output will be somewhat similar to the cat command output.
<br>
<br>
more text.txt text2.txt 
<br>
::::::::::::::
<br>
text.txt
<br>
::::::::::::::
<br>
line1
<br>
line2
<br>
line3
<br>
line4
<br>
line5
<br>
<br>
<br>
<h4>Less</h4>
The less command is similar to the more command, it's named from the phrase "less is more", but provides extensive features.
<br>
Less allows backward and forward movement in the file, can be used after pipes, one argument is accepted.
<br>
cat text.txt text2.txt | less
<br>
line1
<br>
line2
<br>
line3
<br>
line4
<br>
line5
<br>
line6
<br>
line7
<br>
line8
<br>
line9
<br>
line10
<br>
<br>
Less provides several options, as line numbers display.
<br>
less -N text.txt
<br>
      1 line1
<br>
      2 line2
<br>
      3 line3
<br>
      4 line4
<br>
      5 line5
<br>
<br>
<br>
<h4>Grep</h4>
Regular expression: a sequence of characters that specifies a search pattern in text
<br>
Grep: GNU Regular Expression Parser
<br>
<br>
The grep command searches for lines matching a given pattern list, within given files, multiple files are accepted.
<br>
Grep searches for strings in text files and displays the matching lines found.
<br>
<br>
grep line1 text.txt 
<br>
line1
<br>
<br>
Grep provides options that let us exclude matching patterns (-v), if more files are given their names will be displayed before the matching content found in the file.
<br>
<br>
Although the pattern is accepted without quotes, it is strongly suggested to use always double quotes for the string that will be matched by grep.
<br>
<br>
Grep is widely used in scripts because of its versatility, speed, and precision. See # grep --help # man grep
<br>
<br>
grep -v "line1\|line2" text.txt text2.txt 
<br>
text.txt:line3
<br>
text.txt:line4
<br>
text.txt:line5
<br>
text2.txt:line6
<br>
text2.txt:line7
<br>
text2.txt:line8
<br>
text2.txt:line9
<br>
<br>
<br>
<h4>Find</h4>
The find command is aimed to search for files in a directory hierarchy.
<br>
It can find files and directories and perform operations on them (with -exec).
<br>
Find can search files and folders by name, creation date, modification date, owner, permissions.
<br>
Syntax # find [location] [optional expression] [-options] [optional what to find]
<br>
See # find --help # man find
<br>
<br>
find .
<br>
# will display all the contents in the current directory without exclusion
<br>
<br>
find . -type f
# displays all the files in the current path and subdirectories
<br>
<br>
find . -type d
# displays all the directories in the current path and subdirectories
<br>
<br>
find . -type f -name "text*"
./text.txt
./text2.txt
<br>
<br>
find . -type f -iname "Text*"
./text.txt
./text2.txt
<br>
<br>
find . -maxdepth 1 -type f -name "*.txt"
<br>
./ls_current_dir.txt
<br>
./text.txt
<br>
./text2.txt
<br>
<br>
<br>
It's almost impossible to cover all the Linux commands, feel free to explore and search for commands, even using TAB to autocomplete. 
<br>
<br>
eg. digit host and press TAB twice to see all the commands that begin with that pattern 
<br>
host [PRESS TAB TWICE]
<br>
host         hostid       hostname     hostnamectl
<br>
<br>
<br>
The continue search for better commands and options is one reason for the good system administrator to literally consume man and the --help option.
<br>
<br>
<i>Being curious is the best way to learn Linux quickly and in depth.</i>
<br>
<br>
<br>
<h4>A list of commands to explore the features of Bash and Linux</h4>
pwd # try also # echo $HOME
<br>
env # try also # env | grep -i home
<br>
date
<br>
echo "$(date +%s.%N)" #  Epoch time counts number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970
<br>
printf # this one provides useful functions eg. limit to two decimal digits # printf "%.2f" $(date +%s.%N)
<pre>
ls
cd
mkdir
cp
mv
head
tail
tr
cut
diff
cal
wc
ip
ps
ss # or netstat (from net-tools on RPM)
dig # (from bind-utils on RPM)
free
df
du
chmod
chown
curl
wget
top (press h for help , press q to quit)
time # try # time free -h # time find / -type d
</pre>
<br>
<br>
<h4>VI</h4>
vi (Visual Instrument) and vim (vi improved) are popular text editor programs available in many Linux distros.
<br>
<i>Note for learners: press ESC and type :q! to quit vi/vim without saving.</i>
<br>
<br>
Vim is widely used by system administrators to edit scripts, configuration files and text files on Linux.
<br>
<br>
<i>With Vim text editing can be performed quikly because hands stay on the keyboard, without need of moving away to reach the mouse.</i>
<br>
<br>
Vim includes commands to perform text editing with speed and precision.
<br>
<br>
Vim represents one of the most used text editor in the Linux command line, it must be mastered to become Linux experts.
<br>
<br>
Luckily the builtin command "vimtutor" provides a ... vim tutorial to learn it quickly!
<br>
<br>
<b>Basic Vim Commands and Description</b>
<pre>
i           insert mode
Esc         command mode
x (or DEL)  delete a character
X           delete a character in backspace mode
u           undo changes
CTRL + r    redo changes
yy          copy (yank) current line
dd          delete current line
p           paste the clipboard/buffer content (if the last action is copy line, the line will be pasted)
/           followed by a string search for the string, use n and N to cycle matches
[[          or gg move to the beginning of the current file
]]          or G move to the end of the current file
ESC + :w    save file
:%s/old_string/new_string/gci     search old_string and replace it with new_string for all matching occurences, require confirm
ESC + :wq or ESC + ZZ             save file and quit Vim
ESC + :wq! or ESC + :x            force save and quit Vim
ESC + :q! force                   quit Vim discarding all changes
</pre>
<br>
<br>
More commands:
<pre>
sed
awk
sha256sum
openssl
ssh
hexdump
od
dd
stat
type
</pre>
<br>
...for more commands type a couple of letters of a word in the shell and press TAB.
<br>
Remember always to check the manpages and commands help before using them, to avoid unwanted changes or damages.
<br>
<br>
<hr>
<center>
<p>
<a href="https://linuxcram.github.io/10_streams.html">[10_streams]</a>
 &lt; &gt; 
<a href="https://linuxcram.github.io/12_hints.html">[12_hints]</a>
</p>
</center>
<h3><a href="https://linuxcram.github.io/">HOME</a></h3>
<br>
</body>
</html>
