<!DOCTYPE html>
<html>
<style type="text/css">
header {
    width: 960px;
}
body {
  background: #333333;
  color: #BBBBBB;
  font-family: monospace;
  text-align: left;
  margin: 0;
  border: 100px solid transparent;
}
a:link {
  color: #ff6000;
  background-color: transparent;
  text-decoration: none;
}
a:visited {
  color: #00bbbb;
  background-color: transparent;
  text-decoration: none;
}
a:active {
  color: #00bb00;
  background-color: transparent;
}
hr {
  height: 3px;
  background-color: #00ee00;
  border: none;
}
</style>
<head>
<title>linuxcram.github.io - 15_scripts</title>
</head>
<body>
<center>
<img src="https://raw.githubusercontent.com/linuxcram/linuxcram.github.io/main/tux01.png" alt="Tux" width="33" height="33">
<h2>
linuxcram.github.io
<br>
[15_scripts]
</h2>
</center>
<h3><a href="https://linuxcram.github.io/">HOME</a></h3>
<hr>
<b><p id="15_scripts">15_scripts</p></b>
<b>BASH scripts</b>
<br>
<br>
Note: when we are logged on a Linux system the prompt is preceeded by username, hostname, and the &tilde; between [ ], this way of displaying the prompt will be used in some parts of this tutorial.
<br>
Standard users have a $ prompt symbol, while root has a # prompt symbol to distinguish its privileged account.
[username@hostname ~]$
<br>
[root@hostname &tilde;]#
<br>
<br>
<b>Syntax</b>
<br>
<br>
Bash accepts single commands, the terminator is implied with the end of the line, the newline char "\n"
<br>
<br>
[student@linux &tilde;]$ echo "Hello world"
<br>
Hello world
<br>
<br>
This program is represented by a single command with an explicit terminator
<br>
<br>
[student@linux &tilde;]$ echo "Hello world";
<br>
Hello world
<br>
<br>
<b>Commands separators and Exit codes</b>
<br>
<br>
<br>
The ; Command separator allows to execute multiple commands sequentially on a single line, each command is executed regardless of the outcome of the previous command.
<br>
eg. ls -l; free -h; ls -l /rooot; date
<br>
<br>
The &amp;&amp; command separator that will let the second command run, only if the first one runs without errors.
<br>
<br>
The exit code value of 0 means without errors, and it can be checked executing "echo $?" after a command to display its exit code.
<br>
<br>
A non-zero (1-255) exit status means that the command had a failure.
<br>
Common Exit status / Description
<br>
1 	Catchall for general errors
<br>
2 	Misuse of shell builtins
<br>
126 	Command invoked cannot execute
<br>
127 	Command not found
<br>
128 	Invalid argument to exit command
<br>
<br>
eg.
<br>
ls -l && free -h; echo $?
<br>
<br>
"ls -l" is the command to view the long listing format of the current directory contents, the same will be produced by "ls -l ." because the default argument "." is implied by ls command itself, once run in a directory which is readable by our user, it will return an exit code 0 without errors.
<br>
If a command produces an exit code !=0 (not equal to 0) it means an error, and the next command will not be run because of the && separator conditional behavior.
<br>
eg.
<br>
ls -l /rooot && free -h ; echo $?
<br>
ls: cannot access '/rooot': No such file or directory
<br>
2
<br>
<br>
Since the first command produces an error code !=0, the next command free -h is not run, this because the chain of commands is interrupted at the first error detected, "echo $?" will show the exit code of the last command run.
<br>
<br>
Special Variable / Description
<br>
$0&nbsp;&nbsp;&nbsp;&nbsp;The name of the bash script.
<br>
$1, $2...$n&nbsp;&nbsp;&nbsp;&nbsp;The bash script arguments.
<br>
$$&nbsp;&nbsp;&nbsp;&nbsp;The process id of the current shell.
<br>
$#&nbsp;&nbsp;&nbsp;&nbsp;The total number of arguments passed to the script.
<br>
$@&nbsp;&nbsp;&nbsp;&nbsp;The value of all the arguments passed to the script.
<br>
$?&nbsp;&nbsp;&nbsp;&nbsp;The exit status of the last executed command.
<br>
$!&nbsp;&nbsp;&nbsp;&nbsp;The process id of the last executed command.
<br>
<br>
<b>One-Liners</b>
<br>
<br>
A group of multiple commands, separated by ";" or "&&", written on the same line is called a "one-liner".
<br>
eg. this one-liner will produce the output of every single command in sequence
<br>
<br>
echo "---" && ls; echo "---" && free -h; echo "---" && echo "Done" && echo "---";
<br>
<br>
For sake of readability one-liners can be written using the escape character \ to split the commands on multiple lines, but running the commands chaining them togeter.
<br>
<br>
eg. pasting the following lines in the terminal, followed by enter, will run all them in sequence
<br>
<br>
echo "---" && \
<br>
ls; \
<br>
echo "---" && \
<br>
free -h; \
<br>
echo "---" && \
<br>
echo "Today is : $(date)" && \
<br>
echo "---";
<br>
<br>
<b>Hints about "echo"</b>
<br>
<br>
The echo command is a Linux built-in command feature, that behave like a function which displays the arguments given as text, such as strings, variables values, output of commands.
<br>
<br>
Echo return status is always 0.
<br>
<br>
Common echo options are:
<br>
-n    do not output the trailing newline
<br>
-e    enable interpretation of backslash escapes
<br>
-E    disable interpretation of backslash escapes (default)
<br>
<br>
Echo escape sequences:
<br>
\b    Backspace
<br>
\\    Backslash
<br>
\n    New Line
<br>
\r    Carriage Return
<br>
\t    Horizontal Tab
<br>
\v    Vertical Tab
<br>
<br>
eg.
<br>
echo "Today is: $(date) - Logged as user: $(whoami) - Shell: $SHELL"; echo "Exit code: $?"
<br>
<br>
Today is: Mon Dec 12 11:22:29 AM CET 2022 - Logged as user: student - Shell: /bin/bash
<br>
<br>
Exit code: 0
<br>
<br>
<hr>
<center>
<p>
<a href="https://linuxcram.github.io/14_loops.html">[14_loops]</a>
 &lt; &gt; 
<a href="https://linuxcram.github.io/16_operators.html">[16_operators]</a>
</p>
</center>
<br>
</body>
</html>
